/*
Lob

The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> Looking for our [previous documentation](https://lob.github.io/legacy-docs/)? 

API version: 1.3.0
Contact: lob-openapi@lob.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lob

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// IntlAutocompletionsApiService IntlAutocompletionsApi service
type IntlAutocompletionsApiService service

type ApiIntlAutocompletionRequest struct {
	ctx context.Context
	ApiService *IntlAutocompletionsApiService
	intlAutocompletionsWritable *IntlAutocompletionsWritable
	xLangOutput *string
}

func (r ApiIntlAutocompletionRequest) IntlAutocompletionsWritable(intlAutocompletionsWritable IntlAutocompletionsWritable) ApiIntlAutocompletionRequest {
	r.intlAutocompletionsWritable = &intlAutocompletionsWritable
	return r
}

// * &#x60;native&#x60; - Translate response to the native language of the country in the request * &#x60;match&#x60; - match the response to the language in the request  Default response is in English. 
func (r ApiIntlAutocompletionRequest) XLangOutput(xLangOutput string) ApiIntlAutocompletionRequest {
	r.xLangOutput = &xLangOutput
	return r
}

func (r ApiIntlAutocompletionRequest) Execute() (*IntlAutocompletions, *http.Response, error) {
	return r.ApiService.IntlAutocompletionExecute(r)
}

/*
IntlAutocompletion autocomplete

Given an address prefix consisting of a partial primary line and country, as well as optional input of city, state, and zip code, this functionality returns up to 10 full International address suggestions. Not all of them will turn out to be valid addresses; they'll need to be [verified](#operation/intl_verification).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiIntlAutocompletionRequest
*/
func (a *IntlAutocompletionsApiService) IntlAutocompletion(ctx context.Context) ApiIntlAutocompletionRequest {
	return ApiIntlAutocompletionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IntlAutocompletions
func (a *IntlAutocompletionsApiService) IntlAutocompletionExecute(r ApiIntlAutocompletionRequest) (*IntlAutocompletions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntlAutocompletions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IntlAutocompletionsApiService.IntlAutocompletion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/intl_autocompletions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.intlAutocompletionsWritable == nil {
		return localVarReturnValue, nil, reportError("intlAutocompletionsWritable is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xLangOutput != nil {
		localVarHeaderParams["x-lang-output"] = parameterToString(*r.xLangOutput, "")
	}
	// body params
	localVarPostBody = r.intlAutocompletionsWritable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v LobError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
